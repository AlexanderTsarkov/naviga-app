# **Неформальное описание логики присоединения ноды к сессии (JOIN \+ гео-фиксация)**

*(как Naviga решает раздачу short-ID и синхронизацию базовой точки для дельта-координат)*

---

## **0\. Суть в двух словах**

1. В каждой охоте есть **один Session Master (SM)**.

2. Новые ноды шлют ему **JOIN** через сеть с служебным `origin_id = 63`.

3. Сеть простым flood-режимом доставляет JOIN до SM.

4. SM отвечает **JOIN\_ACCEPT**, в котором:

   * выдаёт ноде её `short_id`,

   * сообщает параметры сессии,

   * **передаёт координаты базовой точки (anchor)**, относительно которой все ноды потом шлют позиции как дельты `dx, dy, dz`.

5. После этого нода входит в mesh и начинает слать геоданные уже в дельта-формате.

---

## **1\. Базовый принцип: один Session Master на охоту**

Навига исходит из модели:

* В **каждой охоте** есть **один ведущий** — устройство, которое объявляет:

   «Я — Session Master этой охоты».

Обычно это донгл \+ телефон организатора. Его задачи:

* раздавать **short-ID 0..62** нодам, которые хотят присоединиться;

* держать таблицу `short_id → long_id`;

* задавать параметры сессии (роли, интервалы обновлений, тайминги);

* **зафиксировать и раздать anchor-точку** — базовую гео-координату для дельта-кодирования.

Без SM сеть может жить в аварийном «диком» режиме (fallback),  
 но **нормальная охота** всегда предполагает одного мастера.

---

## **2\. Что знает новая нода при включении**

Когда нода включается в лесу:

* у неё есть только свой **долгий идентификатор** `long_id` (например, MAC ESP32);

* LoRa уже слушает эфир, нода может вести локальную табличку:

   «я слышу такие-то long\_id, вот их RSSI/SNR»;

* **short-ID у неё ещё нет**, в mesh-логике она не участвует;

* про anchor (базовую координату сессии) она пока ничего не знает.

---

## **3\. Как нода узнаёт, что рядом есть охота и какая у неё anchor**

Session Master периодически шлёт короткие **BEACON**\-пакеты:

* «я Session Master такой-то охоты»,

* `session_id`,

* признак «требуется/не требуется код охоты»,

* **координаты anchor** (в полном виде lat/lon\[/alt\]),

  * либо целиком,

  * либо в сжатом/квантованном виде, но однозначно для всей сессии.

Новая нода:

1. **Слушает эфир**.

2. Если слышит BEACON от SM, она понимает:

   * рядом есть охота;

   * вот её `session_id`;

   * вот координаты базовой точки anchor, относительно которой все в этой сессии будут кодировать свои `dx, dy, dz`.

Если долго не слышит ни одного BEACON, можно на уровне UX дать пользователю опцию «создать свою охоту» — то есть самому стать SM и зафиксировать anchor по своему текущему GPS-фиксу. Протокол от этого не страдает.

---

## **4\. Как выбирается anchor (базовая точка координат)**

Типичный сценарий:

1. Организатор охоты включает свой Naviga-ведущий (SM) и ждёт стабильного GPS-фикса.

2. После того как GPS «успокоился», SM:

   * **запоминает текущие координаты как anchor** `(lat0, lon0, alt0?)`,

   * начинает рассылать BEACON-ы, содержащие:

     * `session_id`,

     * anchor,

     * режим доступа (с кодом охоты или без).

Все ноды, присоединившиеся к этой сессии, будут позже:

* хранить у себя `anchor`,

* и передавать свои координаты в виде дельт `dx, dy, dz` от этой точки.

Anchor для данной сессии **фиксируется SM** и может меняться только по его инициативе (например, если явно начата новая сессия).

---

## **5\. Присоединение без кода (базовый JOIN)**

После того как нода услышала хотя бы один BEACON от SM, она знает:

* что сессия существует,

* кто SM,

* какой у сессии `session_id`,

* какую anchor-точку использовать.

Дальше:

1. Нода формирует **JOIN-запрос**:

    «Я такой-то (`long_id`), хочу присоединиться к сессии `session_id`, вот моя роль (dog/driven/shooter/…)».

2. Отправляет JOIN в эфир как **служебный пакет**:

   * с зарезервированным `origin_id = 63`  
      (это **служебный ID**, а не номер ноды; он говорит всем: «это JOIN/CONTROL, а не геопакет»),

   * внутри:

     * `long_id`,

     * `join_nonce` (случайный номер заявки),

     * `requested_role`,

     * `session_id` (на всякий случай, вдруг слышно несколько SM).

3. Остальные ноды:

   * по `origin_id = 63` понимают, что это служебка,

   * **ровно один раз** ретранслируют JOIN дальше, с небольшим TTL (простой flood),

   * mesh не пытается «умничать» с масками/приоритетами — это редкий пакет.

4. JOIN доезжает до SM даже без прямой видимости по радио.

5. Session Master:

   * проверяет, что `session_id` совпадает с его сессией;

   * выбирает свободный `short_id` (0..62, 63 зарезервирован под служебку);

   * привязывает этот `short_id` к `long_id` ноды и её роли;

   * формирует **JOIN\_ACCEPT**.

6. SM отправляет **JOIN\_ACCEPT** в эфир (тоже сервисный пакет, `origin_id = 63`), в котором:

   * `target_long_id` — кому адресован ответ;

   * `join_nonce` — чтобы отличить именно этот запрос;

   * `assigned_short_id` — выданный ноде `short_id`;

   * `role_params` — профиль роли (интервалы, max\_silence и т.п.);

   * **anchor** — либо повторяет координаты anchor (для надёжности), либо даёт ссылку на уже известный BEACON anchor (в простом варианте — просто дублирует lat0/lon0).

7. Остальные ноды, как и в случае JOIN, один раз ретранслируют JOIN\_ACCEPT дальше.

8. Новая нода, получив JOIN\_ACCEPT:

   * проверяет `target_long_id` и `join_nonce`,

   * записывает `my_short_id`,

   * записывает/обновляет `anchor` (если по каким-то причинам в BEACON не успела его надёжно зафиксировать),

   * переходит в режим **полноценного участника mesh**:

     * во всех геопакетах использует `origin_id = my_short_id`,

     * кодирует координаты как `dx, dy, dz` относительно anchor,

     * участвует в логике covered\_mask / best\_mask.

---

## **6\. JOIN с кодом охоты (режим «по приглашению»)**

Если сессия защищена кодом:

1. Организатор в приложении «открывает охоту» и получает **код охоты**.

2. SM в BEACON-ах дополнительно указывает:

   * «для присоединения нужен код»,

   * часть/хэш кода, чтобы отличать разные сессии (опционально).

3. Пользователь на новой ноде:

   * в приложении нажимает «Присоединиться»,

   * вводит код,

приложение формирует JOIN с:

 origin\_id \= 63  
long\_id   \= X  
join\_nonce  
hunt\_code \= H  
session\_id

*   
4. SM:

   * проверяет `hunt_code`,

   * если неверный — игнорирует или шлёт отказ,

   * если верный — всё как в базовом JOIN:

     * выдаёт `short_id`,

     * отправляет JOIN\_ACCEPT с `short_id`, `role_params` и (при необходимости) anchor.

Радиоуровень остаётся тем же: flood JOIN/ACCEPT через сеть, `origin_id = 63` как метка служебки.

---

## **7\. Как это связано с дельта-координатами в обычных геопакетах**

После успешного JOIN нода знает:

1. Свой `short_id`.

2. Anchor `(lat0, lon0, alt0?)`, общую для всей сессии.

3. Профиль роли и временные параметры.

Дальше, в обычных геопакетах:

* вместо передачи «сырых» Lat/Lon/Alt нода:

  * берёт текущий GPS-фикс `(lat, lon, alt)`,

  * пересчитывает его в локальные смещения `(dx, dy, dz)` относительно anchor,

  * кодирует их в компактном целочисленном виде (2–3 байта на ось, в зависимости от диапазона и точности),

  * шлёт в эфир вместе с:

    * `origin_id = short_id`,

    * `bridge_hop_id`,

    * `covered_mask`,

    * `seq`, `hop`, `TTL` и т.п.

Получатель, зная тот же anchor, восстанавливает реальную позицию:

(lat, lon, alt) ≈ anchor \+ inverse\_transform(dx, dy, dz)

Таким образом, **JOIN решает сразу две задачи**:

1. Адресация: выдаёт `short_id`, с которым нода живёт дальше в mesh.

2. Геометрия: синхронизирует anchor-точку, от которой все ноды считают дельты, сокращая размер геопакетов.

---

## **8\. Почему это по-прежнему проще конкурентов**

В сравнении:

* **Huntloc**:

  * код охоты проверяется через сервер,

  * радиоканал — мобильная сеть, там другие лимиты.

* **Garmin**:

  * нужно вручную парить устройства,

  * нет концепции «просто включил и присоединился к ближайшей охоте».

* **Naviga**:

  * в эфире ровно один SM,

  * нода:

    * включилась,

    * услышала BEACON (узнала SM, anchor и режим доступа),

    * послала JOIN,

    * получила short-ID и anchor,

    * и дальше шлёт компактные дельта-координаты как полноценный участник mesh.

Сложная математика и маски начинаются **после** JOIN, а сам процесс входа в сессию остаётся очень простым:  
 одна служебная пара JOIN/JOIN\_ACCEPT на ноду — и всё.

---

Если хочешь, следующим шагом можно из этого неформального описания вытащить «сухой» формат полей JOIN / JOIN\_ACCEPT (структуры, типы, размер в байтах), чтобы это уже можно было отдавать разработчикам как черновик wire-протокола.

