# OOTB v0: анализ документации, план первой итерации и организация работ

Документ: анализ прочитанной продуктовой документации, понимание первой итерации (OOTB v0), подход к организации проекта и приоритизированные задачи для GitHub Projects.

---

## 1. Анализ прочитанной документации

### 1.1. Product Core — ядро продукта

**Суть:** Naviga — система автономной групповой навигации и обмена координатами без мобильных сетей (outdoor: охота, походы, грибники, поиск и т.д.). Канал связи — радиосеть через донглы.

**Слойность:**
- **OOTB (Out of the Box)** — базовый слой, делаем первым. Без охоты, ролей, JOIN, mesh-оптимизаций. Самодостаточный продукт.
- **Охота** — надстройка: сессия, Session Master, short_id, anchor, роли, JOIN/ACCEPT, mesh (covered_mask/best_mask).

**Термины:** Нода = устройство; Донгл = нода с BLE к телефону и радио; Приложение = карта, список нод, лог, настройки.

**Definition of Done OOTB v0** (кратко):
- **Железка (донгл):** BLE к телефону (подключение, базовые настройки); радио — периодический `GEO_BEACON` (свои координаты), приём чужих; NodeTable (long_id, last_seen, last_pos, RSSI/SNR, battery, таймаут «устаревших»); мост NodeTable/события в приложение по BLE.
- **Приложение:** подключение к донглу по BLE; список нод (давность, RSSI/SNR, батарея); ноды на карте; «я» (позиция телефона); минимальный локальный лог.
- **Жёсткие не-цели:** short_id, JOIN/Session Master, mesh covered_mask/best_mask, backend, охота в UX.

**Архитектура:** Mobile App ⇄(BLE)⇄ Dongle ⇄(Radio)⇄ Другие ноды.

**Дорожная карта (Milestone):**
- **M0** — док-ядро и карта проекта: Product Core, Architecture Index, OOTB Radio v0 spec, OOTB BLE v0 spec, Test Plan v0.
- **M1** — OOTB End-to-End v0: firmware (beacon + NodeTable + BLE API), mobile (BLE + list + map), полевой тест 2–5 нод.
- **M2** — сценарий «Охота» (надстройка).

---

### 1.2. OOTB — письмо (Out of the box и активация сценариев)

**Идея:** База — отдельный продукт «из коробки», не черновик под охоту. Устройство работает сразу: без настроек/сессий, редко (не чаще раза в минуту) шлёт простой геопакет (long_id, Lat/Lon, время, батарея). Любая нода ведёт таблицу нод; телефон показывает ноды на карте, лог, имена. Поверх базы — включаемые сценарии (охота, парапланы и т.д.) со своими пакетами, mesh, ролями, UI.

**Вывод для OOTB v0:** Один тип пакета (GEO_BEACON), NodeTable, никакого mesh или минимальный; интервал — редко (порядка минуты или по спецификации Radio v0).

---

### 1.3. Вижн (Decision Edition)

**Контекст:** Рынок (Garmin дорого/закрыто, HuntLoc требует интернет). Решение — мобильное приложение + донгл (Bluetooth + LoRa/DMR), 3–5 км, при необходимости mesh. Аппаратура: донгл (BLE, LoRa, USB), ошейник/маяк (позже; в OOTB v0 можно вторую ноду как донгл без телефона). Старт 868 МГц, Россия.

**Для OOTB v0:** Фокус на донгле и приложении; ошейник/маяк не обязателен для первой итерации.

---

### 1.4. JOIN и Mesh — будущие слои

- **JOIN:** Session Master, short_id, anchor, дельта-координаты. Для OOTB v0 не нужен (только long_id, полные координаты в beacon).
- **Mesh:** covered_mask, best_mask, ретрансляции, QoD, полезность. Для OOTB v0 не нужен (простейший beacon, без mesh или минимальный flood).

Документы JOIN и Mesh использовать как референс границ: в OOTB v0 их не реализуем.

---

## 2. Понимание первой итерации (OOTB v0)

### 2.1. Цель итерации

Работающий фундамент «из коробки»:
- быстрый старт (включил — видишь ноды);
- полный цикл: донгл шлёт/принимает GEO_BEACON, ведёт NodeTable, отдаёт данные в приложение по BLE; приложение показывает список и карту, «я», минимальный лог.

### 2.2. Scope OOTB v0 (кратко)

| Компонент     | В scope                                                                 | Вне scope                    |
|--------------|--------------------------------------------------------------------------|------------------------------|
| **Firmware** | BLE (подключение, настройки), радио (GEO_BEACON TX/RX), NodeTable, мост в приложение | short_id, JOIN, mesh, роли   |
| **Mobile app** | BLE-клиент, список нод, карта, «я», базовый лог                        | Охота, сессии, роли, backend |
| **Протокол** | Один тип пакета (GEO_BEACON), формат и правила (частота, TTL, stale)     | Служебные пакеты JOIN/Mesh   |

### 2.3. Критерии готовности (Definition of Done)

- Донгл подключается к приложению по BLE, отдаёт снапшот NodeTable и/или события обновлений.
- Донгл периодически шлёт GEO_BEACON, принимает чужие, обновляет NodeTable, помечает ноды по таймауту.
- Приложение показывает список видимых нод (давность, RSSI/SNR, батарея), ноды на карте, «я» (если разрешено), минимальный локальный лог.
- Полевой тест: 2–5 нод обмениваются и отображаются стабильно.

---

## 3. Подход к организации проекта

### 3.1. Принципы

- **Архитектура прежде кода:** спецификации (Radio v0, BLE v0), Architecture Index и Test Plan — до реализации.
- **Максимально модульная организация кода:** один файл — одна чёткая задача; небольшие, простые для чтения и ревью.
- **Ориентация на конкретную задачу:** имена файлов и модулей отражают ответственность (например, `node_table_storage`, `geo_beacon_tx`, `ble_node_table_bridge`).
- **Комментарии только на границах:** публичные интерфейсы, инварианты, причины решений и допущения. Остальное — читаемый код + короткие docstrings. (Иначе легко получить «романы» вместо кода.)

### 3.2. Структура репозитория (монорепо)

- `app/` — мобильное приложение (Flutter).
- `firmware/` — прошивка.
- `backend/`, `web/` — позже.
- `docs/` — product, architecture, protocols, firmware, mobile-app, backend, web, adr.
- `tools/` — скрипты.
- `.github/workflows/` — CI (минимальные гейты с нулевой бюрократией).
- `_archive/` — архив старых ad-hoc экспериментов и POC.

### 3.3. Где что описывать (важно: протоколы отдельно)

- **docs/product/** — продуктовые решения, OOTB v0 DoD, тест-план как продуктовая проверка.
- **docs/architecture/** — Architecture Index, диаграммы, границы компонентов.
- **docs/protocols/** — wire-контракты: Radio v0, BLE v0, JOIN, Mesh.
- **docs/firmware/** — архитектура слоёв firmware, NodeTable как доменная модель, реализации/модули.
- **docs/mobile-app/** — архитектура приложения, экраны, контракт с firmware по BLE (ссылка на docs/protocols/ootb_ble_v0.md).
- **docs/adr/** — решения (ADR): границы OOTB, выбор Map SDK, выбор формата ID/координат и т.п.

### 3.4. Почему «протоколы = не вся архитектура»

В первоначальной логике «архитектурного» блока фигурировали в основном **OOTB Radio v0** и **OOTB BLE v0** — то есть форматы пакетов и BLE-контракт. Это **не полная архитектура**, а только часть: контракт «на границе» (wire format), чтобы firmware и app могли разрабатываться параллельно и стыковаться по одному интерфейсу.

**Что критично добавить, чтобы не превратить код в “всё в одном”:**
- **Слои прошивки:** domain (бизнес-логика) отдельно от протокола (кодеки/сериализация) и отдельно от драйверов/железа (HAL).
- **NodeTable как доменная модель:** типы, инварианты, stale-политика, лимиты, контракт передачи по BLE.
- **Абстракции железа + моки:** чтобы domain/protocol можно было тестировать без реального железа и параллелить работу.

### 3.5. Полный объём архитектуры (многоуровневость)

**Firmware — три уровня (сверху вниз):**
1. **Domain/Application:** правила “когда/что делаем” (beacon schedule, NodeTable, stale).
2. **Protocol:** “как кодируем/декодируем” (GEO_BEACON, BLE формат снапшота/событий).
3. **Driver/HAL:** “как реально отправляем/принимаем” (конкретный радио модуль, BLE стек).

**NodeTable — отдельная спецификация:**
- Поля записи о ноде, единицы, инварианты.
- Обновление/устаревание/лимиты/вытеснение.
- Контракт с приложением: что и как отдаём по BLE.

**App — уровни (кратко):** UI → доменная модель (Node, NodeTable) → BLE-клиент (контракт по BLE v0).

---

## 4. Предпосылки и открытые решения (чтобы никто не угадывал)

### 4.1. Assumptions (зафиксированные предпосылки)

1) **Источник координат в OOTB v0:** координаты берёт **донгл** (GNSS на донгле). Пока GNSS-железо не готово — используем **GNSS-stub**, генерирующий позиции вокруг заданной точки (для тестов/демо).
2) **Node ID (long_id):** используем **MAC ESP32** (8 байт) как long_id, пока не появится причина менять.
3) **OOTB карта в v0:** **онлайн** (оффлайн не требуется), но Map SDK выбираем с прицелом на будущий оффлайн.
4) **OOTB v0 = без охоты/JOIN/mesh:** протоколы JOIN/Mesh не трогаем, только референс.
5) **POC уже был:** существует архив тестовой прошивки/кода, где проверены радио-обмен (ESP32+E220, очередность/ack, мощность) и отдельные BLE тесты. Нужно оформить это как “evidence” и список пробелов.

### 4.2. Open Questions & Decisions (закрывать по задачам; BLOCKER — без ответа нельзя двигаться)

1) **[BLOCKER] Map SDK (Flutter):** какой SDK берём (с перспективой оффлайна), чтобы не перепиливать архитектуру мобилки потом?
2) **Beacon interval default:** стартуем с “раз в минуту” или быстрее для демо? Нужны дефолт и объяснение компромисса (батарея/нагрузка).
3) **Stale policy v0:** какие состояния у ноды (active / stale / lost?) и по каким таймерам/коэффициентам (max_silence_interval, role_pos_update_interval, factor)?
4) **Coordinate encoding:** формат lat/lon (fixed-point 1e-7? микрограды?) и точность (~1м). Зафиксировать минимальный рабочий формат + возможность смены версии.
5) **Time field:** нужен ли timestamp в GEO_BEACON v0 (и какой: unix seconds? uptime?), или достаточно last_seen локально на приёмнике?
6) **Battery field:** откуда берём батарею в v0 и в каких единицах (0–100, mV)? Если пока неизвестно — placeholder.
7) **Max NodeTable size:** сколько записей держим на донгле, и какая политика вытеснения (LRU, oldest_seen)?
8) **Radio parameters:** канал/частота/мощность/скорость — дефолты для v0 (и как конфигурируются через BLE).
9) **BLE contract shape:** snapshot vs event-stream vs оба. Для v0 достаточно snapshot по запросу + notify “changed”?
10) **Logging export path:** BLE characteristic vs UART. Что точно будет доступно на стенде/в поле?
11) **“Firmware-only” этап:** хотим ли официально выделить шаг “донгл↔донгл + локальный UI (экран на макетке)” как промежуточный E2E перед мобилкой?
12) **Compatibility/versioning:** как версионируем GEO_BEACON/BLE payload (1 байт version в заголовке?) чтобы без боли менять формат.

---

## 5. Задачи в порядке приоритета (для GitHub Projects)

Задачи сгруппированы по фазам; внутри фазы порядок приоритетный. Сначала минимальные гейты и фиксация фактов (POC evidence), затем документация и архитектура, затем реализация.

### Фаза 0 — Подготовка трекера, CI и карты проекта (первым делом)

| # | Задача | Описание | Тип |
|---|--------|----------|-----|
| 0.1 | Настроить GitHub Project под OOTB v0 | Board/Views: Backlog, M0 (Docs), M1 (Build), Done. Статусы: Todo, In Progress, Review, Done. | Организация |
| 0.2 | Завести Epic «OOTB End-to-End v0» | Один Epic, к нему привязать все задачи фаз 0–4. | Организация |
| 0.3 | Минимальный CI (гейты) | GitHub Actions: (1) firmware compile/build (минимум компиляция), (2) `flutter analyze` + build, (3) formatter/linter. | Инфра |
| 0.4 | Решение по Map SDK (offline-friendly) | ADR: выбрать Map SDK для Flutter. В OOTB v0 используем онлайн, но SDK должен позволять оффлайн позже. | Решение (ADR) |

### Фаза 0.5 — POC Evidence & Gaps (зафиксировать, что уже проверено)

| # | Задача | Описание | Тип |
|---|--------|----------|-----|
| 0.5.1 | Документ POC Evidence | Описать проведённые smoke-тесты: радио (ESP32+E220, конкурентная отправка, ack, управление мощностью) и отдельные BLE тесты. Где лежит архив. | Документация |
| 0.5.2 | Список пробелов/рисков | Что НЕ покрыто: GNSS реальный, интеграция BLE↔radio в одном цикле, карты/SDK, логирование в поле и т.п. | Документация |
| 0.5.3 | Навести порядок в архиве | Переместить весь старый ad-hoc код в `_archive/` с README “что это и зачем”. Ничего не удалять. | Организация |

### Фаза 1 — Документация и архитектура (M0)

Порядок: сначала **архитектура (слои, NodeTable, абстракция железа)**, затем **протоколы (wire format)** — чтобы протоколы опирались на уже зафиксированную модель данных и уровни.

| # | Задача | Описание | Тип |
|---|--------|----------|-----|
| 1.1 | Architecture Index | Документ-карта: компоненты (firmware, app), слои внутри каждого, модули/файлы и ответственность. Разместить в `docs/architecture/`. | Документация |
| 1.2 | Архитектура firmware: слои и границы | Явное разделение: (1) Domain, (2) Protocol, (3) Driver/HAL. Интерфейсы между уровнями. Файл: `docs/firmware/ootb_firmware_arch_v0.md`. | Архитектура |
| 1.3 | Спецификация NodeTable | Структура записи, типы/единицы, правила stale, лимиты и вытеснение. Контракт с приложением. Файл: `docs/firmware/ootb_node_table_v0.md`. | Документация |
| 1.4 | Абстракции железа (HAL) | Описать интерфейсы `IRadio`, `IBleTransport`, `IGnss`, `ILog` + принципы моков. Файл: `docs/firmware/hal_contracts_v0.md` или ADR. | Архитектура |
| 1.5 | OOTB Radio v0 — спецификация | GEO_BEACON: формат полей, версия, порядок байт, дефолты параметров (интервал, max_silence, etc.). Файл: `docs/protocols/ootb_radio_v0.md`. | Документация |
| 1.6 | OOTB BLE v0 — спецификация | GATT: сервисы/характеристики, формат снапшота/событий NodeTable, версия. Файл: `docs/protocols/ootb_ble_v0.md`. | Документация |
| 1.7 | Test Plan v0 | Сценарии проверки OOTB v0 + что логировать/собирать. Файл: `docs/product/ootb_test_plan_v0.md`. | Документация |
| 1.8 | ADR: границы OOTB v0 | Краткий ADR: что входит в OOTB v0, что вынесено (JOIN, Mesh, охота). Файл: `docs/adr/ootb_scope_v0.md`. | Документация |

### Фаза 2 — Реализация firmware (M1, часть 1)

Сначала делаем **интерфейсы и моки**, чтобы можно было писать domain/protocol и тестировать без железа, затем драйверы, затем кодеки и доменная логика.

| # | Задача | Описание | Тип |
|---|--------|----------|-----|
| 2.0 | HAL interfaces + mock implementations | Реализовать интерфейсы `IRadio`, `IBleTransport`, `IGnss`, `ILog` + моки (для тестов/ПК/без железа). | Код |
| 2.1 | Дерево модулей firmware по слоям | Папки/модули: `domain/`, `protocol/`, `hal/` (и `hal/mocks`). README в firmware с границами. | Архитектура |
| 2.2 | Logging v0 (ring-buffer + export) | События: TX/RX, decode ok/err, NodeTable update, BLE notify. Экспорт по BLE или UART (решение фиксируется). | Код |
| 2.3 | HAL радио (реальный драйвер) | Реализация `IRadio` под выбранное железо (например, Ebyte E220-400T30D). Бизнес-логика не знает о железе. | Код |
| 2.4 | HAL BLE (реальный транспорт) | Реализация `IBleTransport` под выбранный BLE-стек (ESP32). | Код |
| 2.5 | Протокол GEO_BEACON (кодер/декодер) | По `docs/protocols/ootb_radio_v0.md`: encode/decode. | Код |
| 2.6 | NodeTable (domain) | По `docs/firmware/ootb_node_table_v0.md`: хранение, stale, лимиты. | Код |
| 2.7 | Логика beacon (domain) | Периодическая отправка своего beacon, обработка приёма, обновление NodeTable. | Код |
| 2.8 | BLE-мост NodeTable (protocol + hal) | По `docs/protocols/ootb_ble_v0.md`: snapshot/events. | Код |
| 2.9 | Интеграция и тест firmware на стенде | Сборка, прогон с 2 донглами, проверка обмена, NodeTable и логов. | Тест |

### Фаза 3 — Реализация mobile app (M1, часть 2)

| # | Задача | Описание | Тип |
|---|--------|----------|-----|
| 3.1 | Структура модулей app | Слои: BLE-клиент, домен (Node, NodeTable), UI. Отразить в Architecture Index. | Архитектура |
| 3.2 | BLE-клиент и контракт с firmware | Подключение к донглу, получение NodeTable/событий по BLE v0. | Код |
| 3.3 | Доменная модель (Node, NodeTable) | Модели и репозиторий/стейт. | Код |
| 3.4 | Экран списка нод | Давность, RSSI/SNR, батарея. | Код |
| 3.5 | Карта и «я» | Отображение нод на карте, позиция «я». (OOTB v0: онлайн; SDK выбран в 0.4.) | Код |
| 3.6 | Базовый локальный лог | Минимальный лог (события/обновления). | Код |
| 3.7 | Интеграция и E2E тест | App + реальный/эмулированный донгл: подключение, список, карта, лог. | Тест |

### Фаза 4 — Полевой тест и закрытие M1

| # | Задача | Описание | Тип |
|---|--------|----------|-----|
| 4.1 | Полевой тест 2–5 нод | По Test Plan v0: выезд, проверка обмена/отображения, сбор логов. | Тест |
| 4.2 | Фиксация результатов и обновление доков | Обновить Test Plan результатами, при необходимости — Radio/BLE spec и ADR. | Документация |

---

## 6. Рекомендуемое использование в GitHub Projects

- **Projects:** один проект «Naviga» с полями: Status, Phase (0–4), Type (Документация / Архитектура / Код / Тест / Инфра / Организация), Component (firmware / app / docs / общее).
- **Epic:** одна issue «Epic: OOTB End-to-End v0»; дочерние задачи — по списку выше.
- **Правило “no guessing”:** если тикет требует решения — он должен иметь блок `Decisions needed` + `Defaults`, иначе Cursor начнёт угадывать.
- **Порядок выполнения:** Фаза 0 → 0.5 → 1 → 2 → 3 → 4. Внутри Фазы 2: HAL+mocks → logging → реальные HAL → кодеки → домен → BLE-мост → стенд.

---

## 7. Следующий шаг

1) Выполнить Фазу 0 (трекер + CI + Map SDK ADR) и Фазу 0.5 (POC evidence + архив).
2) Закрыть Фазу 1 (Architecture Index + NodeTable + HAL contracts + Radio/BLE specs + Test Plan).
3) После появления `docs/protocols/ootb_radio_v0.md` и `docs/protocols/ootb_ble_v0.md` — начинать реализацию Фазы 2/3 строго по слоям и с гейтами CI.
