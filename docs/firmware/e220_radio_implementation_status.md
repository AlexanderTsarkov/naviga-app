# Поддержка радиомодуля E220 (UART): текущее состояние реализации

**Цель документа:** зафиксировать, что именно реализовано и работает, где проходит граница «модем через библиотеку» vs «полноценный радиодрайвер», чтобы устранить путаницу в терминологии перед дальнейшими шагами.

**Дата:** 2026-02-06  
**Источник:** код в `firmware/`, документация POC и smoke-тестов в `docs/`.

---

## 1. Архитектурный уровень

### Классификация поддержки радио

- **Текущая реализация:** UART-модем (E220) через внешнюю библиотеку. Обмен с модулем — по UART (протокол/команды библиотеки, поверх которых модуль может использовать AT-подобный протокол производителя).
- **Не реализовано:** прямой SPI-драйвер радиочипа (LLCC68/SX126x и т.п.). К радиочипу внутри E220 мы не обращаемся; весь обмен идёт через модуль как «чёрный ящик» с UART-интерфейсом.

### Взаимодействие с интерфейсами проекта

- **IRadio** (`firmware/lib/NavigaCore/include/naviga/hal/interfaces.h`): абстракция «отправить/принять payload + last_rssi». Единственная реализация для железа — **E220Radio** (`firmware/src/platform/e220_radio.cpp`), реализует `send`, `recv`, `last_rssi_dbm()`.
- **Runtime:** `M1Runtime` (`firmware/src/app/m1_runtime.cpp`) в каждом тике вызывает `IRadio::send` / `IRadio::recv`. Радио получает указатель на `IRadio*` при инициализации; не использует никакой другой радио-интерфейс.
- **BeaconLogic** (domain): не знает о радио. Строит payload (GEO_BEACON) и принимает декодированный payload при RX; решение «когда отправлять» и вызов `radio->send()` выполняет runtime (через BeaconLogic.build_tx + BeaconSendPolicy).
- **IChannelSense:** в коде добавлен как опциональный HAL для LBT/CAD. Для E220 **не используется**: в `app_services.cpp` в `runtime_.init(..., nullptr)` передаётся `nullptr` в качестве channel sense. Документация (issue #76) явно указывает: E220 UART — channel sense **UNSUPPORTED** в текущем драйвере.

---

## 2. Используемая библиотека / код

### Библиотека

- **Пакет:** `xreef/EByte LoRa E220 library` (PlatformIO Registry).
- **Подключение:** в `firmware/platformio.ini` в секциях env `esp32dev`, `devkit_e220_oled`, `devkit_e220_oled_gnss` указано:
  ```ini
  lib_deps =
    xreef/EByte LoRa E220 library
  ```
- **В коде:** `firmware/src/platform/e220_radio.h` подключает `#include <LoRa_E220.h>`. Класс `naviga::E220Radio` хранит экземпляр `LoRa_E220 radio_` и вызывает его методы.

### Используем ли мы готовые AT-команды модуля или обёртку библиотеки

- Прямых вызовов AT-команд из кода Naviga **нет**. Вся работа с модулем идёт через API библиотеки LoRa_E220: `begin()`, `getConfiguration()`, `setConfiguration()`, `sendMessage()`, `receiveMessage()` / `receiveMessageRSSI()`. Библиотека сама формирует протокол обмена с E220 (внутри — запросы/ответы по UART; точный формат в репозитории Naviga не описан, см. исходники библиотеки).

### Режимы модуля

- В коде Naviga **режим модуля явно не переключается**. После `radio_.begin()` вызываются только:
  - `getConfiguration()` — чтение текущей конфигурации;
  - изменение в конфиге: `cfg->TRANSMISSION_MODE.enableRSSI = RSSI_ENABLED`;
  - `setConfiguration(*cfg, WRITE_CFG_PWR_DWN_LOSE)` — запись конфига.
- Отправка/приём — через `sendMessage()` и `receiveMessage()` / `receiveMessageRSSI()`. Режим работы (normal / config / fixed) определяется библиотекой и конфигом модуля; в нашем коде явно фигурирует только включение RSSI в конфиге. Режим «normal» для TX/RX подразумевается использованием именно этих методов.

---

## 3. Реально поддерживаемые возможности (по факту)

| Возможность | Статус | Как реализовано |
|-------------|--------|------------------|
| Инициализация модуля | ✔️ | `E220Radio::begin()` → `radio_.begin()` (библиотека). Успех сохраняется в `ready_`. |
| Установка дефолтных параметров | ✔️ (частично) | Читаем текущий конфиг через `getConfiguration()`, меняем только `enableRSSI = RSSI_ENABLED`, пишем через `setConfiguration(..., WRITE_CFG_PWR_DWN_LOSE)`. Остальные параметры — как выставлены на модуле/библиотекой при begin. |
| Отправка payload | ✔️ | `send(data, len)` → `radio_.sendMessage(data, (uint8_t)len)`. Ограничение длины: `len <= MAX_SIZE_TX_PACKET` (200, константа из библиотеки). |
| Приём payload | ✔️ | `recv(out, max_len, out_len)` → при `radio_.available() > 0` вызывается `receiveMessageRSSI(max_len)` или `receiveMessage(max_len)`; данные копируются в `out`, длина в `*out_len`. |
| Получение RSSI | ✔️ | Только при приёме: если при инициализации удалось включить RSSI в конфиге (`rssi_enabled_ == true`), используется `receiveMessageRSSI()`, значение `response.rssi` сохраняется в `last_rssi_dbm_` и возвращается из `last_rssi_dbm()`. Отдельного запроса RSSI/шума без приёма пакета нет. |
| Channel sensing / LBT / CAD | ❌ | Не реализовано. Интерфейс `IChannelSense` в проекте есть, но для E220 в runtime передаётся `nullptr`. В `docs/firmware/stand_tests/issue_76_radio_channel_access.md` указано: E220 UART — channel sense **UNSUPPORTED** в текущем драйвере. |
| Управление радиочипом на уровне регистров | ❌ | Нет доступа к регистрам чипа (LLCC68 и т.п.). Взаимодействие только с модулем E220 по UART через библиотеку. |

---

## 4. Где проходит граница «драйвера»

### a) Текущая поддержка E220 как UART-модема

- **E220Radio** — это **адаптер к библиотеке** LoRa_E220: один класс, один файл реализации, который переводит вызовы `IRadio` в вызовы `radio_.begin()`, `sendMessage()`, `receiveMessage()` / `receiveMessageRSSI()` и при необходимости читает/пишет конфиг для RSSI.
- Мы не знаем и не задаём частоту, SF, BW, пресеты и т.д. из кода Naviga — они определяются конфигом модуля и тем, как библиотека/модуль их устанавливают. Мы не отправляем сырые команды по UART и не парсим ответы модуля вручную.
- Такая реализация осознанно **не называется «полным драйвером радиочипа»**: нет доступа к чипу, нет регистров, нет CAD/LBT на уровне нашего кода, нет тонкого контроля параметров радиоканала из прошивки.

### b) Будущий SPI-драйвер (LLCC68 / SX126x и т.п.)

- Под «полноценным» драйвером обычно подразумевают: обмен по SPI с радиочипом, запись/чтение регистров, настройка частоты/SF/BW/TX power из прошивки, при необходимости — CAD (Channel Activity Detection), LBT, DIO-прерывания и т.д.
- Для E220 в варианте **UART** мы этого не делаем: модуль сам содержит чип и прошивку, мы общаемся только с модулем. Вариант **E22-400T30D (SPI)** в этом документе не рассматривается; в POC evidence упоминается UART-вариант.

### Почему текущая реализация не называется полным драйвером радиочипа

- Нет прямого доступа к радиочипу (только к модулю по UART).
- Нет управления параметрами радиоканала из кода (частота, мощность и т.д. задаются конфигом/библиотекой/модулем).
- Нет реализации LBT/CAD в нашем стеке; интерфейс под это есть (IChannelSense), но для E220 не используется и помечен как UNSUPPORTED.

---

## 5. История решения (коротко)

- В POC и при переносе в Naviga был выбран подход **использовать внешнюю библиотеку** для E220 (см. `docs/firmware/poc_e220_evidence.md`): не писать свой низкоуровневый протокол UART и не дублировать код; зафиксировать зависимость в `platformio.ini` и не копировать библиотеку в репо.
- В `platformio.ini` зафиксирована зависимость `xreef/EByte LoRa E220 library` для env с E220. Это соответствует решению «подтягивать как зависимость».
- Для текущего этапа (OOTB v0, beacon-обмен, два устройства на стенде) этого достаточно: быстрый вывод в эфир, проверка обмена, единый контракт IRadio для runtime и тестов.
- **Реальный радиообмен между двумя устройствами** зафиксирован: в [_archive/research/issue_21/smoke_test_pr59_issue21_results.md](../../_archive/research/issue_21/smoke_test_pr59_issue21_results.md) описаны два ESP32 с одной прошивкой (devkit_e220_oled), роли INIT (PING) и RESP (PONG), успешная прошивка и проверка по логам и OLED (TX/RX/SEQ). Итог: «Serial logs confirm correct roles … Final confirmation of PING/PONG is by observing TX/RX/SEQ (and RAD state) on the OLED after ~10 s.»

---

## 6. Вывод

- **Состояние радио-части:** Реализована работа с E220 как с UART-модемом через библиотеку xreef/EByte LoRa E220: инициализация, включение RSSI в конфиге, отправка и приём payload, получение RSSI по приёму. Граница «драйвера» — ровно адаптер IRadio → LoRa_E220; ниже — только библиотека и модуль. Channel sensing / LBT / CAD в нашем коде для E220 не реализованы и не подключены (IChannelSense = nullptr).
- **Что можно делать дальше без изменения радио-уровня:** Менять протокол (размер/формат beacon), политику отправки (jitter, backoff), логирование, BLE-экспорт NodeTable — всё это не требует замены E220Radio или библиотеки. Включение LBT/CAD для E220 потребует либо поддержки в библиотеке/модуле с экспортом в наш IChannelSense, либо явного решения «оставить UNSUPPORTED».
- **Что потребует отдельного шага:** Полноценный SPI-драйвер (LLCC68/SX126x и т.п.) с регистрами, CAD, тонкой настройкой параметров; смена модуля/платформы; реализация «полного MAC» поверх нашего стека — всё это выходит за рамки текущей реализации E220 UART-модема.
