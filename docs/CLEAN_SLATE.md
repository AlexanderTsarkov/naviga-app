# Переход на «чистый лист»: архив POC и структура продукта

## Цель

Сохранить текущее состояние (POC, прототипы, тесты и документы) в архиве, затем организовать репозиторий для разработки реального продукта.

## Что именно «почистили»

**Продукт Naviga не связан с Meshtastic.** Всё, что делалось раньше — уровень POC: быстрое прототипирование и адаптация существующих решений для проверки предположений. POC-задачи выполнены, состояние заархивировано.

**«Чистый лист» = структура репо и код:**

1. **Структура** — вариант B (app/, firmware/, backend/, web/, docs с подкаталогами, tools); снимок POC в archive/.
2. **Код** — в app/ удалён весь POC-код (интеграция с Meshtastic, proto, сервисы, экраны). Оставлен минимальный каркас Flutter-проекта. Продукт Naviga будем делать с нуля, шаг за шагом, с пониманием каждого файла.

Архив (archive/poc-YYYYMMDD) сохранён; при необходимости к старому коду можно обратиться. В новой структуре он не нужен.

---

## Шаг 1: Создать архив текущего состояния

### Что войдёт в архив

| В архив | Описание |
|---------|----------|
| **naviga_app/** | Весь код Flutter-приложения (POC) |
| **docs/** | Текущее содержимое docs (перед архивом можно вернуть удалённые файлы из git) |
| **tools/** | Скрипты (dual_serial_log.py и др.) |
| **firmware-release/** | Собранные бинарники прошивки |
| **README.md**, **README_GIT_SETUP.md** | Описание и инструкции по Git |
| **setup_naviga_branch.sh** | Скрипт настройки ветки firmware |
| **MANIFEST** | Ссылки на репо meshtastic-* и коммиты (чтобы при необходимости заново клонировать) |

### Что не копировать в архив (слишком большое / отдельные репо)

- **meshtastic-android/**, **meshtastic-ios/**, **meshtastic-firmware/** — отдельные git-репозитории. В архиве сохраняется только **MANIFEST** с URL и текущим коммитом; при необходимости их можно заново клонировать по этому манифесту.

### Как создать архив

```bash
# Из корня репо Naviga
./tools/archive_poc_state.sh
```

Скрипт создаст каталог `archive/poc-YYYYMMDD/` (с датой запуска) и положит туда перечисленное выше + MANIFEST для meshtastic-*.

**Перед первым запуском:** если нужно включить в архив ранее удалённые файлы из `docs/`, выполните один раз:

```bash
git restore docs/
```

После этого запустите `./tools/archive_poc_state.sh` — в архив попадёт полная текущая версия `docs/`.

---

## Шаг 2: Восстановить удалённые документы (опционально)

Чтобы в архиве была полная документация (включая удалённые в рабочей копии файлы):

```bash
git restore docs/
```

Список файлов, которые вернутся из git (если они были удалены с диска):

- `docs/Meshtastic_Flutter_API_Guide.md`
- `docs/Position data.md`
- `docs/Troubleshooting position updates.md`
- `docs/meshtastic_flutter_cursor.md`
- `docs/meshtastic_position_telemetry_flutter_cursor.md`
- `docs/product/naviga_vision_decision_edition.md`
- `docs/План реализации POC.md`

---

## Шаг 3: «Чистый лист» — предложенная структура продукта

После архивации можно привести репозиторий к виду «только продукт».

### Состав продукта Naviga

- **Документация** — одна директория `docs/`, с подкаталогами по областям (firmware, mobile app, backend, web).
- **Firmware** — прошивка устройств (на базе Meshtastic).
- **Mobile app** — Flutter (iOS + Android).
- **Backend** — серверная часть.
- **Web app** — веб-приложение.

### Рекомендация: Вариант B (расширенный)

Для такого состава лучше всего подходит **вариант B** — чёткое разделение по частям продукта в одном репозитории (monorepo):

| Вариант | Почему подходит / не подходит |
|---------|-------------------------------|
| **A** | Минимальные изменения, без явного разделения на firmware/backend/web. Подходит только как временный этап; для пяти частей продукта структура быстро станет неочевидной. |
| **B** | Один репо, в корне — по папке на каждую часть (app, firmware, backend, web, docs, tools). Одна общая документация в `docs/` с подкаталогами по областям. Просто навигировать, один `git clone`, единая история и релизы. **Рекомендуется.** |
| **C** | Monorepo + submodules — уместен, когда часть кода живёт во внешних репо (например референс meshtastic-*). Для своего кода (firmware, backend, web) лучше держать всё в одном репо; submodules — только для внешних зависимостей при необходимости. |

Итого: **выбирайте B** — одна директория на каждую часть продукта, общая `docs/` с подкаталогами по областям.

Целевая структура репозитория:

```
Naviga/
├── docs/                      # Вся документация проекта
│   ├── firmware/              # Документы по прошивке
│   ├── mobile-app/            # Документы по Flutter-приложению
│   ├── backend/                # Документы по бэкенду
│   ├── web/                   # Документы по веб-приложению
│   ├── design/                # Общий дизайн, архитектура
│   ├── adr/                   # Architecture Decision Records (опционально)
│   └── ...                    # Общие: видение, планы, гайды
│
├── app/                       # Mobile app (Flutter, iOS + Android)
│   ├── lib/
│   ├── android/
│   ├── ios/
│   └── ...
│
├── firmware/                  # Прошивка (свой код или submodule на форк Meshtastic)
├── backend/                   # Серверная часть
├── web/                       # Веб-приложение
│
├── tools/                     # Скрипты сборки, отладки, утилиты
├── archive/                   # Архив POC (опционально)
├── README.md
└── .gitignore
```

Референсные репо Meshtastic (meshtastic-android, meshtastic-ios, meshtastic-firmware) остаются локальными копиями, в `.gitignore`; см. docs/REFERENCE_REPOS.md.

---

### В чём реальная разница между B и C

| | Вариант B | Вариант C |
|---|-----------|-----------|
| **Структура** | Одинаковая: app/, firmware/, backend/, web/, docs/, tools/ в одном репо. | Та же. |
| **Свой код** | Весь ваш код (firmware, backend, web, app) лежит в этом репо — обычные папки, обычные коммиты. | То же. |
| **Внешний код** (референс, форк Meshtastic и т.п.) | Как решите: можно не класть в репо (локальные клоны + .gitignore), можно оформить как **submodule** на свой форк. | Явно через **submodules**: внешние репо подключаются как submodule, при `git clone --recursive` они подтягиваются в фиксированных коммитах. |

Итого: **B** — «структура + гибкость»: как подключать внешние репо (submodule или просто локальный клон) вы выбираете сами. **C** — «структура + жёсткое правило»: внешние репо только через submodules. Для Naviga достаточно **B**: референс Meshtastic можно держать в .gitignore; если позже понадобится firmware как submodule (например свой форк) — добавите submodule в папку `firmware/`, не меняя общей структуры.

---

### Библиотеки (E220-400T30D, LoRa, GPS) — копировать к себе или внешние зависимости?

Это **не** «внешние референсы» в смысле B/C. Разделение такое:

| Тип | Примеры | Как поступать |
|-----|---------|----------------|
| **Библиотеки / пакеты** (драйверы радио, GPS, протоколы) | E220-400T30D, LoRa-стек, драйверы GPS для PlatformIO/Arduino; npm/pip пакеты для backend/web | **Не копировать в репо.** Объявлять как **зависимости** (platformio.ini, pubspec.yaml, requirements.txt, package.json). Сборка подтягивает их сама (pio lib install, flutter pub get, pip install, npm install). Версии фиксируются в lock-файлах (buf.lock, package-lock.json и т.д.). |
| **Референсные проекты** (целый репо «как сделано у других») | Meshtastic firmware, Meshtastic Android/iOS | Локальные клоны (в .gitignore) или submodule — только чтобы **смотреть** архитектуру и решения. В сборку Naviga не входят. |
| **Свой код поверх библиотек** (обёртки, конфиги, интеграция) | Ваш код, который использует E220/GPS/LoRa | Это **ваш код** — лежит в `firmware/` (или app/backend/web), коммитится в репо как обычно. |
| **Вендорные SDK / бинарники** (нет в менеджере пакетов) | Закрытые библиотеки, специфичные бинарники | Иногда кладут в репо в `vendor/` или `third_party/` и коммитят, либо документируют «скачать с X и положить сюда». |

Пример для прошивки: в `firmware/` у вас свой код; зависимости на RadioLib, драйвер E220, GPS — в **platformio.ini** (или аналоге). Вы **не** копируете эти библиотеки в репо — их подтягивает PlatformIO. В репо попадает только ваш код и список зависимостей (+ при необходимости патчи в `patches/` или копия только если библиотеки нет в реестре и вы её форкаете).

---

### Вариант A: Минимальные изменения

- Оставить в корне только то, что нужно для разработки продукта.
- **naviga_app/** — переименовать или оставить как основное приложение; постепенно вычищать POC-код, оставляя только продакшен-путь.
- **docs/** — оставить; добавить структуру (например `docs/design/`, `docs/ops/`, `docs/adr/`).
- **tools/** — оставить для скриптов сборки/отладки.
- **meshtastic-*** — решить: либо вынести в отдельные репо и подключать как submodules, либо держать клоны вне этого репо (например в соседних папках), а в Naviga оставить только ссылки и инструкции в README.

### Вариант B: Чёткое разделение app / firmware / docs

```
Naviga/
├── app/                 # бывший naviga_app (Flutter)
├── firmware/            # submodule или ссылка на репо прошивки Naviga
├── docs/
│   ├── design/
│   ├── adr/
│   └── ...
├── tools/
├── archive/             # архив POC (poc-YYYYMMDD)
├── README.md
└── ...
```

- **app** — единственное приложение в репо; всё лишнее из POC со временем удаляется или выносится в примеры.
- **firmware** — либо git submodule на форк meshtastic-firmware (ветка Naviga), либо отдельный репо + инструкция в README.
- **meshtastic-android** и **meshtastic-ios** не обязаны лежать в этом репо; достаточно документации и MANIFEST в архиве для референса.

### Вариант C: Monorepo с submodules

- Оформить **meshtastic-firmware** (и при желании android/ios) как submodules.
- В корне — только навигация по проекту, общие docs и tools, плюс `naviga_app` как основной код приложения.

Рекомендация на старте: **Вариант A** (минимум изменений, архив создан, дальше — по мере необходимости переходить к B или C).

---

## Шаг 4: Что сделать сразу после архива

1. Запустить `./tools/archive_poc_state.sh` и убедиться, что `archive/poc-YYYYMMDD/` создан и в нём есть naviga_app, docs, tools, firmware-release, MANIFEST.
2. (Опционально) Закоммитить добавление архива и новых документов (`docs/REPO_STRUCTURE.md`, `docs/CLEAN_SLATE.md`, `tools/archive_poc_state.sh`).
3. Решить, по какому варианту (A/B/C) двигаться, и завести задачи на реорганизацию (переименование, вынос firmware, очистка POC в app).
4. Обновить **README.md** под выбранную структуру и указать путь к актуальной документации (в т.ч. к `docs/REPO_STRUCTURE.md` и `docs/CLEAN_SLATE.md`).

---

## Краткий чеклист

- [ ] Восстановить удалённые файлы в `docs/` при необходимости: `git restore docs/`
- [ ] Запустить `./tools/archive_poc_state.sh`
- [ ] Проверить содержимое `archive/poc-YYYYMMDD/` и MANIFEST
- [ ] Выбрать вариант структуры (A / B / C)
- [ ] Закоммитить архив и новые документы/скрипты
- [ ] Обновить README и при необходимости .gitignore

После этого можно считать, что переход от ad-hoc и прототипирования к разработке продукта начат с «чистого листа» при сохранённом архиве текущего кода и документов.
